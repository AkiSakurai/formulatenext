// Copyright...

#ifndef RICH_FORMAT_H_
#define RICH_FORMAT_H_

#include <string>
#include <vector>

#include <ft2build.h>
#include FT_FREETYPE_H

namespace formulate {

// Helper class to parse HTML. For example, the following str would
// trigger the following callbacks:
// 'Hi <b class="cl">There</b><br />Rock&amp;Roll!'
// Text("Hi ");
// NodeStarted("b");
// NodeAttribute("class", "cl");
// Text("There");
// NodeEnded();
// NodeStarted("br");
// NodeEnded();
// Text("Rock&Roll!");

class HTMLNodeWalkerInterface {
 public:
  virtual void HTMLText(const char* text) {}  // not HTML encoded
  virtual void HTMLNodeStarted(const char* tag_name) {}
  virtual void HTMLNodeAttribute(const char* key, const char* value) {}
  virtual void HTMLNodeEnded() {}
};

void HTMLWalk(const char* str, HTMLNodeWalkerInterface* callbacks);

// This class can take a simple HTML snippet of text and convert it to
// a PDF text object stream.

// One design principle is that this class only tries to be able to
// parse the HTML that's generated by the javascript layer, and we try
// to keep it as simple as possible.

class RichFormat : public HTMLNodeWalkerInterface {
 public:
  RichFormat();

  std::string Format(const char* html, float width);

  void HTMLText(const char* text);
  void HTMLNodeStarted(const char* tag_name);
  void HTMLNodeAttribute(const char* key, const char* value) {}
  void HTMLNodeEnded();

 private:
  struct Style {
    std::string PDFStyle() const;

    bool bold_{false};
    bool italic_{false};
    // TODO(adlr): font, size, color, underline
    // For now assume Helvetica, 12, black, no underline
  };

  // Keep a stack of style. Each time a style is changed (e.g. on
  // <b>), we push the new version. When a style is over (e.g. </b>),
  // we pop the latest. The last element (style_.back()) is the
  // current style.
  std::vector<Style> style_;

  // Here, we keep track of all the characters in a row. full_ascent
  // is the max of [ascent + 1/2 extra leading] for each char.
  // full_descent is max of [descent + 1/2 of extra leading] for each
  // char.  Extra leading is defined as: a font's leading (aka line
  // height) minus [a font's acent + descent]. If extra leading is
  // negative, we treat it as zero.
  //
  // If a user clicks on the text, we can use this structure to find
  // which caret position they are going for.
  class RenderChar;
  class RenderStyle;

  class RenderElement {
   public:
    virtual ~RenderElement() {}
    virtual bool IsRenderChar() = 0;
    virtual RenderChar* AsRenderChar() { return nullptr; }
    virtual bool IsRenderStyle() = 0;
    virtual RenderStyle* AsRenderStyle() { return nullptr; }
  };

  class RenderChar : public RenderElement {
   public:
    RenderChar(float advance, float ideal_adv, uint16_t char_code)
        : advance_(advance), ideal_advance_(ideal_adv), char_code_(char_code) {}
    bool IsRenderChar() { return true; }
    RenderChar* AsRenderChar() { return this; }
    bool IsRenderStyle() { return false; }

    float advance_;
    float ideal_advance_;
    uint16_t char_code_;
  };

  class RenderStyle : public RenderElement {
   public:
    RenderStyle(const Style& style) : style_(style) {}
    bool IsRenderChar() { return false; }
    RenderStyle* AsRenderStyle() { return this; }
    bool IsRenderStyle() { return true; }
    
    Style style_;
  };

  struct RenderRow {
    std::vector<std::unique_ptr<RenderElement>> elements_;
  };
  // Each row has a RenderRow object:
  std::vector<RenderRow> render_;

  // TODO(adlr): have a font cache
  FT_Library ftlib_;
  FT_Face arimo_;
};

}  // namespace formulate

#endif  // RICH_FORMAT_H_
